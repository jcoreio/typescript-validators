// @flow

import Type from './types/Type'
import AnyType from './types/AnyType'
import ArrayType from './types/ArrayType'
import BooleanLiteralType from './types/BooleanLiteralType'
import BooleanType from './types/BooleanType'
import InstanceOfType from './types/InstanceOfType'
import IntersectionType from './types/IntersectionType'
import NullLiteralType from './types/NullLiteralType'
import UndefinedLiteralType from './types/UndefinedLiteralType'
import NumberType from './types/NumberType'
import NumericLiteralType from './types/NumericLiteralType'
import ObjectType from './types/ObjectType'
import ObjectTypeProperty from './types/ObjectTypeProperty'
import RecordType from './types/RecordType'
import StringLiteralType from './types/StringLiteralType'
import StringType from './types/StringType'
import SymbolLiteralType from './types/SymbolLiteralType'
import SymbolType from './types/SymbolType'
import TupleType from './types/TupleType'
import UnionType from './types/UnionType'
import TypeAlias from './types/TypeAlias'
import TypeReference from './types/TypeReference'
import Validation from './Validation'
import RuntimeTypeError from './errorReporting/RuntimeTypeError'
import oneOf from './oneOf'

export {
  Type,
  AnyType,
  ArrayType,
  BooleanLiteralType,
  BooleanType,
  InstanceOfType,
  IntersectionType,
  NullLiteralType,
  UndefinedLiteralType,
  NumberType,
  NumericLiteralType,
  ObjectType,
  ObjectTypeProperty,
  RecordType,
  StringLiteralType,
  StringType,
  SymbolLiteralType,
  SymbolType,
  TupleType,
  UnionType,
  TypeAlias,
  TypeReference,
  Validation,
  RuntimeTypeError,
  oneOf,
}

declare export function any(): Type<any>

declare export function array<T>(elementType: Type<T>): Type<T[]>

declare export function nullLiteral(): Type<null>
export { nullLiteral as null }
declare export function nullOr<T>(type: Type<T>): Type<T | null>

declare export function undefinedLiteral(): Type<void>
export { undefinedLiteral as undefined }

declare export function nullish<T>(type: Type<T>): Type<?T>
declare export function nullishOr<T>(type: Type<T>): Type<?T>

declare export function boolean(): Type<boolean>
declare export function boolean<T: true | false>(literal: T): Type<T>
declare export function boolean(
  literal?: boolean
): Type<boolean> | Type<true> | Type<false>

declare export function number(): Type<number>
declare export function number<T: number>(literal: T): Type<T>
declare export function number(
  literal?: number
): Type<number> | Type<true> | Type<false>

declare export function string(): Type<string>
declare export function string<T: string>(literal: T): Type<T>
declare export function string(
  literal?: string
): Type<string> | Type<true> | Type<false>

declare export function symbol(): Type<symbol>
declare export function symbol<T: symbol>(literal: T): Type<T>
declare export function symbol(
  literal?: symbol
): Type<symbol> | Type<true> | Type<false>

type OptionalProperty<T> = { __optional__: Type<T> }

declare export function optional<T>(type: Type<T>): OptionalProperty<T>

declare export function optionalNullOr<T>(
  type: Type<T>
): OptionalProperty<T | null>

type OptionalKeys<T> = {
  [K in keyof T]: T extends Record<K, T[K]> ? never : K
} extends {
  [_ in keyof T]: infer U
}
  ? {} extends U
    ? never
    : U
  : never

export const object = <S extends Record<string | number | symbol, unknown>>({
  exact,
}: { exact?: boolean } = {}) => <
  P extends {
    [K in keyof S]-?: K extends OptionalKeys<S>
      ? OptionalProperty<any>
      : Type<any>
  }
>(
  properties: P
): ObjectType<
  {
    [K in keyof S]: P[K] extends OptionalProperty<infer T>
      ? T
      : P[K] extends Type<infer T>
      ? T
      : never
  }
> =>
  new ObjectType(
    [...Object.entries(properties)].map(
      ([key, type]) =>
        new ObjectTypeProperty(
          key,
          getOptional(type) || (type as Type<any>),
          Boolean(getOptional(type))
        )
    ),
    exact
  ) as any

type Properties = { [string | number | symbol]: Type<any> }

declare export function simpleObject<Required: Properties>(
  required: Required,
  options: ?{ exact?: boolean }
): ObjectType<$ObjMap<Required, <T>(T) => $PropertyType<T, '__type'>>>

declare export function record<K: string | number | symbol, V>(
  key: Type<K>,
  value: Type<V>
): RecordType<K, V>

declare export function instanceOf<T>(classType: {
  new(...args: any[]): T,
}): Type<T>

declare export function tuple<T: Type<any>[]>(
  ...types: T
): Type<$TupleMap<T, <T>(T) => $PropertyType<T, '__type'>>>

declare export function allOf<T1>(...types: [Type<T1>]): Type<T1>
declare export function allOf<T1, T2>(
  ...types: [Type<T1>, Type<T2>]
): Type<T1 & T2>
declare export function allOf<T1, T2, T3>(
  ...types: [Type<T1>, Type<T2>, Type<T3>]
): Type<T1 & T2 & T3>
declare export function allOf<T1, T2, T3, T4>(
  ...types: [Type<T1>, Type<T2>, Type<T3>, Type<T4>]
): Type<T1 & T2 & T3 & T4>
declare export function allOf<T1, T2, T3, T4, T5>(
  ...types: [Type<T1>, Type<T2>, Type<T3>, Type<T4>, Type<T5>]
): Type<T1 & T2 & T3 & T4 & T5>
declare export function allOf<T1, T2, T3, T4, T5, T6>(
  ...types: [Type<T1>, Type<T2>, Type<T3>, Type<T4>, Type<T5>, Type<T6>]
): Type<T1 & T2 & T3 & T4 & T5 & T6>
declare export function allOf<T1, T2, T3, T4, T5, T6, T7>(
  ...types: [
    Type<T1>,
    Type<T2>,
    Type<T3>,
    Type<T4>,
    Type<T5>,
    Type<T6>,
    Type<T7>
  ]
): Type<T1 & T2 & T3 & T4 & T5 & T6 & T7>
declare export function allOf<T1, T2, T3, T4, T5, T6, T7, T8>(
  ...types: [
    Type<T1>,
    Type<T2>,
    Type<T3>,
    Type<T4>,
    Type<T5>,
    Type<T6>,
    Type<T7>,
    Type<T8>
  ]
): Type<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8>
declare export function allOf(...types: Type<any>[]): Type<any>

declare export function alias<T>(name: string, type: Type<T>): TypeAlias<T>

declare export function ref<T>(type: () => TypeAlias<T>): Type<T>

export type ExtractType<T: Type<any>> = $PropertyType<T, '__type'>
